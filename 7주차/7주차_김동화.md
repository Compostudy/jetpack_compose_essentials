# Chapter 48 : Gesture

- tap, double tap, long press, drag, zoom, rotation, ...

## Click Gesture

~~~
@Composable
fun ClickGesture() {

    var colorState by remember { mutableStateOf(true) }
    var bgColor by remember { mutableStateOf(Color.Blue) }

    val clickHandler = {

        colorState = !colorState

        bgColor = if (colorState) {
            Color.Blue
        } else {
            Color.DarkGray
        }
    }

    Box(modifier = Modifier
        .clickable { clickHandler() }
        .background(bgColor)
        .size(100.dp))

}
~~~

## PointerInputScope

- clickable Modifier 는 탭, 프레스, 롱프레스, 더블탭 등을 구분하지 못함

~~~
@Composable
fun TabPressGesture() {

    var textState by remember { mutableStateOf("No Gesture") }

    val tapHandler = { status: String ->
        textState = status
    }

    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier.fillMaxSize()
    ) {
        Box(
            modifier = Modifier
                .background(Color.Blue)
                .size(100.dp)
                .pointerInput(Unit) {
                    detectTapGestures(
                        onPress = { tapHandler("onPress") },
                        onDoubleTap = { tapHandler("onDoubleTap") },
                        onLongPress = { tapHandler("onLongPress") },
                        onTap = { tapHandler("onTap") }
                    )
                }
        )
        Spacer(Modifier.height(10.dp))
        Text(text = textState)
    }
}
~~~

## Drag Gesture

~~~
@Composable
fun DragGesture() {

    Box(Modifier.fillMaxSize()) {

        var x by remember { mutableStateOf(0f) }

        Box(Modifier
            .offset { IntOffset(x.roundToInt(), 0) }
            .size(100.dp)
            .background(Color.Blue)
            .draggable(
                orientation = Orientation.Horizontal,
                state = rememberDraggableState {
                    x += it
                }
            ))
    }
}
~~~

## PointerInputScope Drag

- PointerInputScope는 수직 수평 동시 조작 지원

~~~
Modifier
  .pointInput(Unit) { _, distance
      x += distance.x
      y += distance.y
  }
~~~

## Scrollable

~~~
@Composable
fun ScrollableModifier() {

    var offset by remember { mutableStateOf(0f) }

    Box(
        Modifier
            .fillMaxSize()
            .scrollable(
                orientation = Orientation.Vertical,
                state = rememberScrollableState {
                    offset += it
                    it
                }
            ))
    {
        Box(Modifier
            .size(90.dp)
            .offset { IntOffset(0, offset.roundToInt()) }
            .background(Color.Red))
    }
}
~~~

## Scrollables

~~~
@Composable
fun ScrollableModifiers() {

    val image = ImageBitmap.imageResource(id = R.drawable.img)

    Box(
        Modifier
            .size(150.dp)
            .verticalScroll(rememberScrollState())
            .horizontalScroll(rememberScrollState())
    ) {
        Canvas(Modifier.size(300.dp, 300.dp)) {
            drawImage(
                image = image,
                topLeft = Offset(0f, 0f)
            )
        }
    }
}
~~~

## Pinch / Rotation / Transform Gesture

~~~
@Composable
fun MultiTouch() {

    var scale by remember { mutableStateOf(1f) }
    var angle by remember { mutableStateOf(0f) }
    var offset by remember { mutableStateOf(Offset.Zero) }

    val state = rememberTransformableState { scaleChange, offsetChange, rotationChange ->
        scale += scaleChange
        angle += rotationChange
        offset += offsetChange
    }

    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Box(
            Modifier
                .graphicsLayer(
                    scaleX = scale,
                    scaleY = scale,
                    rotationZ = angle,
                    translationX = offset.x,
                    translationY = offset.y
                )
                .transformable(state)
                .background(Color.Blue)
                .size(100.dp)
        )
    }
}
~~~

# Chapter 49 : Swipe Gesture

- Anchor : 스와이프 축을 따라 화면에 존재하는 고정된 위치
- Threshold : 두 앵커 사이의 한 지점(임계점)으로, 임계점에 도달 전 스와이프 모션이 끝나면 첫 앵커로, 임계점을 넘으면 다음 앵커로 움직인다.
- Modifier의 swipeable() 모디파이어를 호출해 사용

## Parameters

- state: SwipeableState
- anchor: Map -앵커 지점들과 상태들을 연결
- orientation: Orientation
- enabled: Boolean
- reverseDirection: Boolean
- thresholds: (from, to) - 앵커 사이 임계점들의 위치 지정
- resistance: ResistanceConfig?
- velocityThreshold: Dp

## Anchor

~~~
val swipeableState = rememberSwipeableState("On")
val anchors = mapOf(0f to "On", 150f to "Off", 300f to "Locked")

... swipeableState.currentValue
~~~

## Threshold

~~~
{ _, _ -> FractionalThreshold(0.5f) } // 비율
{ _, _ -> FractionalThreshold(20.dp) } // 고정 포인트
~~~

## Component Swipe

~~~
Text(swipeableState.currentValue,
    modifier = Modifier.offset { IntOffset(swipeableState.offset.value.roundToInt(), 0) }
    )
~~~

## Tutorial

~~~
@OptIn(ExperimentalMaterialApi::class)
@Composable
fun SwipeTutorial() {

    val parentBoxWidth = 320.dp
    val childBoxSides = 30.dp

    val swipeableState = rememberSwipeableState(initialValue = "L")
    val widthPx = with(LocalDensity.current) {
        (parentBoxWidth - childBoxSides).toPx()
    }

    val anchors = mapOf(
        0f to "L", widthPx / 2 to "C", widthPx to "R"
    )

    Box(
        Modifier
            .padding(20.dp)
            .width(parentBoxWidth)
            .height(childBoxSides)
            .swipeable(
                state = swipeableState,
                anchors = anchors,
                thresholds = { _, _ -> FractionalThreshold(0.5f) },
                orientation = Orientation.Horizontal
            )
    ) {
        Box(modifier = Modifier
            .offset { IntOffset(swipeableState.offset.value.roundToInt(), 0) }
            .size(childBoxSides)
            .background(Color.Blue),
            contentAlignment = Alignment.Center
        ) {
            Text(
                text = swipeableState.currentValue,
                color = Color.White,
                fontSize = 22.sp
            )
        }
    }
}
~~~

# Chapter 50 : Flow

- 코루틴 기반의 비동기 태스크들로부터 순차적으로 여러 값을 반환할 수 있도록 설계
- producer, intermediary, consumer로 구성
- Producer
    1. Rest API / Local DB 에서 데이터를 가져온다.
    2. flow{ } 블록 내부에서 emit()을 통해 생성
- Intermediary
    1. Producer에서 생성된 데이터를 수정한다.
- Consumer
    1. 수정된 데이터를 사용한다.
    2. flow에서 collect를 이용해 전달받은 데이터를 소비한다.
    3. 일반적으로 소비자는 UI 이다.

## Tutorial

- 생산자 블록(Producer Block) : 데이터 스트림을 생성하는 코드를 해당 선언에서 할당
- flowOf(), asFlow() : Flow로 변환, 소비자가 수집 시작 즉시 자동으로 데이터 방출, 이외는 emit()을 통해 방출
- collect() (종단 플로 연산자) :  또한 코루틴 스코프 안에서 호출되어야 하므로 LaunchedEffect 이용
- collectLatest() : 수집되지 않은 값들을 버리지 않는 collect()와 달리 latest는 새로운 값이 도착하면 현재 컬렉션에 대한 동작을 취소
- single() : 단일한 값 수집, 다른 값을 발견하면 예외 던짐
- reduce() : accumulator에 저장된 결과 사용, 지정된 동작을 accumulator와 value 사이에서 수행
- fold() : reduce와 유사, 초깃값 전달
- Flatten : 플로에서 여러 태스크가 생성될 때, 플로우를 단일 스트림으로 평탄화한다.
- flatMapConcat : 여러 스트림을 하나의 플로로 연결, 동기적 실행, flatMapMerge : 비동기적 실행
- zip() : 여러 플로우를 단일 플로로 조합, 여러 플로가 모두 새로운 값을 방출한 뒤 수집 시작
- combine() : zip과 유사, 여러 플로 중 한 플로가 새로운 값을 방출할 때, 다른 값의 새로운 방출이 없으면 최근 방출한 이전 값을 이용 → 더 많은 출력

~~~
// gradle
implementation 'androidx.lifecycle:lifecycle-viewmodel-compose:2.6.1'
implementation 'androidx.lifecycle:lifecycle-runtime-ktx:2.6.1'

// Main

@Composable
fun FlowTutorial1(viewModel: FlowViewModel = viewModel()) {

    // 1. Without Intermediary
//    val count by viewModel.myFlow.collectAsState(initial = 0)

    // 2. Intermediate Flow Operator
//    val count by viewModel.newFlow.collectAsState(initial = "Value =")

    // 3. Terminal Flow Operator
//    var count by remember { mutableStateOf("Value =") }
//
//    LaunchedEffect(Unit) {
//        try {
//            viewModel.newFlow.collect {
//                count = it
//            }
//        } finally {
//            count = "Flow stream ended"
//        }
//    }

    // 4. Buffer
//    var count by remember { mutableStateOf(0) }
//
//    LaunchedEffect("Unit") {
//        val elapsedTime = measureTimeMillis {
//            viewModel.myFlow
//                .buffer()
//                .collect {
//                    count = it
//                    delay(1000)
//                }
//        }
//
//        count = elapsedTime.toInt()
//    }

//    // 5. reduce, fold
//    var count by remember { mutableStateOf(0) }
//
//    LaunchedEffect(Unit) {
//        viewModel.myFlow
//            .reduce { accumulator, value ->
//                count = accumulator
//                accumulator + value
//            }
//            .fold(10) { accumulator, value ->
//                count = accumulator
//                accumulator + value
//            }
//    }

    // 6. Flatten
//    var count by remember { mutableStateOf(0) }
//
//    LaunchedEffect(Unit) {
//        viewModel.myFlow
//            .flatMapConcat { viewModel.doubleIt(it) }
//            .flatMapMerge { viewModel.doubleIt(it) }
//            .collect {
//                count = it
//            }
//    }

    // 7. zip, combine
//    var count by remember { mutableStateOf("") }
//
//    LaunchedEffect(Unit) {
//        val flow1 = (1..5).asFlow()
//            .onEach { delay(1000) }
//        val flow2 = flowOf("one", "two", "three", "four", "five")
//            .onEach { delay(1500) }
//
//        flow1.zip(flow2) { value, string -> "$value, $string" }
//            .collect { count = it }
//
//        flow1.combine(flow2) { value, string -> "$value, $string" }
//            .collect { count = it }
//    }


    Column(
        modifier = Modifier.fillMaxSize(),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
//        Text(text = count, style = TextStyle(fontSize = 40.sp))
    }
}

// ViewModel

class FlowViewModel : ViewModel() {

    val myFlow: Flow<Int> = flow {
        for (i in 1..9) {
            delay(2000)
            emit(i)
        }
    }

    val newFlow = myFlow
        .filter { it % 2 == 0 }
//        .map { "Current value = $it" }
        .transform {
            emit("Value = $it")
            delay(1000)
            val doubled = it * 2
            emit("Value = $doubled")
        }

    fun doubleIt(value: Int) = flow {
        emit(value)
        delay(1000)
        emit(value * value)
    }
}

~~~

## Hot / Cold Flow
