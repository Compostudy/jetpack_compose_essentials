# Chapter 29 : ConstraintLayout 원리

## ConstraintLayout 동작 원리

### 제약

- 컴포저블의 정렬과 위치를 상대적으로 조정하는 규칙
- 기기 방향의 변경, 다른 화면 크기에 반응하는 등의 상황에 대한 대응방법 지정

### 마진

- 고정된 거리의 여백을 지정
- 고정값을 사용하기 때문에 기기 회전, 다양한 화면에 표시 등에는 덜 유연함 → 응답성을 지니려면 반대 제약 구현 추천


### 반대 제약

- 동일한 축을 따라 한 컴포저블이 가진 2개의 제약
- 특정한 축에 대해 반대 제약이 구현되면 좌표 기반이 아닌 비율로 위치를 정의함

### 제약 편향

- 제약 조건에 대해 지정된 백분율만큼 치우치도록 할 수 있다

### 체인

- 2개 이상 컴포저블을 포함하는 레이아웃의 동작 방법 제공
- 수평축, 수직축 기준으로 선언
- 체인 안에 있는 컴포넌트들의 간격과 크기 정의
- 체인 헤드 : 체인 기준 왼쪽 위의 기준 컴포넌트

### 체인 스타일

- Spread Chain / Spread Inside Chain / Weighted Chain / Packed Chain

### 크기 설정

5개 옵션 제공: 
1. Dimension.preferredWrapContent
2. Dimension.wrapContent
3. Dimension.fillToConstraints
4. Dimension.preferredValue
5. Dimension.value

### 가이드라인 헬퍼

- 추가적으로 연결될 수 있는 제약 제공
- 여러 가이드라인 추가 가능
- 여러 요소를 축에 맞춰 정렬할 때 유용

### 배리어 헬퍼

- 가상의 뷰로 컴포저블들을 레이아웃 안에 표시되도록 제한
- 배리어에 따라 그룹화된 레퍼런스 컴포넌트 요소들 중 기준 컴포넌트인 제약 컴포넌트에 맞춰 배리어 위치 조정

# Chapter 30 : ConstraintLayout 다루기

- 기본으로 포함되지 않아서 라이브러리 설정 추가 필요

~~~
dependencies {
    implementation 'androidx.constraintlayout:constraintlayout-compose:1.0.1'
}
~~~

- 다른 컴포저블과 동일한 형태로 제공됨
- 제약을 받을 컴포저블은 참조를 먼저 할당해야 한다. → 참조를 개별 컴포저블에 적용
- linkTo(참조), center...To(참조), centerAround(참조) 등으로 제약을 추가한다

~~~
@Composable
fun ConstraintLayoutEx1() {
    ConstraintLayout(Modifier
        .size(200.dp, 200.dp)
        .background(Color.Green)) {
        val text1 = createRef()

        val (button1, text2, text3) = createRefs()

        Text(text = "text1", Modifier.constrainAs(text1) {
            top.linkTo(parent.top)
            bottom.linkTo(parent.bottom, margin = 16.dp)
        })

        Text(text = "text2", Modifier.constrainAs(text2) {
            linkTo(parent.start, parent.end, bias = 0.8f)
            linkTo(text1.top, text1.bottom)
        })

        Text(text = "text3", Modifier.constrainAs(text3) {
            centerVerticallyTo(text1)
            centerHorizontallyTo(parent)
        })

        Button(onClick = { /*TODO*/ }, Modifier.constrainAs(button1) {
            centerAround(text3.end)
        }) {

        }
    }
}
~~~

## 동작 원리 적용

### 반대 제약

-컴포저블 양쪽 끝이 자리가 같은 축을 따라 제약되어 있을 때 만들어짐
~~~
linkTo(parent.start, parent.end)
~~~

- 중앙 배치만을 위해 반대 제약을 이용하려면 아래 코드도 이용 가능
~~~
centerVertically(parent) / centerHorizontally(parent)
~~~

### 제약 편향

~~~
linkTo(parent.start, parent.end, bias = 0.75f)
~~~

### 제약 마진

- 제약 커넥션 끝에서 나타나며, 편향 조정, 레이아웃 변경 등에도 이동할 수 없는 고정된 간격을 의미
~~~
linkTo(parent.start, parent.end, startMargin = 30.dp)
~~~

- 반대 제약 커넥션 없이 제약을 적용하면 적절한 반응형 레이아웃을 만들 수 없음
- 기기 회전, 화면 크기에 따라서도 동일한 위치에 표시될 수 있게 제약을 고려해야 함

### 체인

- createHorizontalChain() or createVerticalChain() 을 호출하고 컴포넌트 참조를 파라미터로 전달
- chainStyle 적용 가능

~~~
@Composable
fun ChainFunction() {
    ConstraintLayout(Modifier.size(200.dp, 200.dp)) {

        val (button1, button2, button3) = createRefs()

        createHorizontalChain(button1, button2, button3,
            chainStyle = ChainStyle.SpreadInside)

        Button(onClick = { /*TODO*/ }, Modifier.constrainAs(button1) {
            centerVerticallyTo(parent)
        }) { Text(text = "button1") }

        Button(onClick = { /*TODO*/ }, Modifier.constrainAs(button2) {
            centerVerticallyTo(parent)
        }) { Text(text = "button2") }

        Button(onClick = { /*TODO*/ }, Modifier.constrainAs(button3) {
            centerVerticallyTo(parent)
        }) { Text(text = "button3") }
    }
}
~~~

### 가이드라인

- 수평, 수직의 앵커 라인 제공 → 특정 축을 기준으로 정렬할 때 유용함
- 부모의 폭, 높이 기준으로 비율 지정 or 가장자리에서 특별한 오프셋 지정

~~~
@Composable
fun GuideLineFunction() {
    ConstraintLayout(Modifier.size(200.dp, 200.dp)) {

        val (button1, button2, button3) = createRefs()
        val guide = createGuidelineFromStart(fraction = 0.6f)

        Button(onClick = { /*TODO*/ }, Modifier.constrainAs(button1) {
            top.linkTo(parent.top, margin = 20.dp)
            end.linkTo(guide, margin = 30.dp)
        }) { Text(text = "button1") }

        Button(onClick = { /*TODO*/ }, Modifier.constrainAs(button2) {
            top.linkTo(button1.bottom, margin = 20.dp)
            start.linkTo(guide, margin = 40.dp)
        }) { Text(text = "button2") }

        Button(onClick = { /*TODO*/ }, Modifier.constrainAs(button3) {
            top.linkTo(button2.bottom, margin = 40.dp)
            end.linkTo(guide, margin = 20.dp)
        }) { Text(text = "button3") }
    }
}
~~~

### 배리어

- 컴포넌트 참조를 전달하면 start, end 는 수직 / top, bottom은 수평 배리어를 만든다.

~~~
@Composable
fun BarrierFunction() {
    ConstraintLayout(Modifier.size(350.dp, 220.dp)) {
        val (button1, button2, button3) = createRefs()
        val barrier = createEndBarrier(button1, button2, margin = 30.dp)

        Button(onClick = { /*TODO*/ },
            Modifier
                .width(100.dp)
                .constrainAs(button1) {
                    top.linkTo(parent.top, margin = 20.dp)
                    start.linkTo(parent.start, margin = 8.dp)
                }) { Text(text = "button1") }

        Button(onClick = { /*TODO*/ },
            Modifier
                .width(150.dp)
                .constrainAs(button2) {
                    top.linkTo(button1.bottom, margin = 20.dp)
                    start.linkTo(parent.start, margin = 8.dp)
                }) { Text(text = "button2") }

        Button(onClick = { /*TODO*/ },
            Modifier
                .width(100.dp)
                .constrainAs(button3) {
                    linkTo(parent.top, parent.bottom)
                    linkTo(barrier, parent.end)
                    width = Dimension.fillToConstraints
                    height = Dimension.fillToConstraints
                }) { Text(text = "button3") }
    }
}
~~~

### 
