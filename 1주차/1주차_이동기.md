# 1주차 (Chapter 18 ~ 23)

## 컴포즈 개요(Chapter 18)

### 컴포즈 이전의 개발
- 컴포즈 이전에 안드로이드 스튜디오에서는 XML파일을 만들 수 있는 레이아웃 편집기 도구를 제공하였다.
- 씬에서 컴포넌트를 선택하여 다양한 프로퍼티에 접근하여 속성을 변경할 수 있다.
- 사용자 이벤트에 반응하는 모든 컴포넌트는 이벤트를 처리하는 앱의 소스 코드 메서드에 연결된다.
- 시뮬레이터 또는 실제 기기에서 실행하면서 테스트해야 했다.

### 컴포즈의 선언적 구문
- 선언한 레이아웃 배치, 제한, 렌더링 방법에 관한 모든 복잡한 세부 사항은 컴포즈가 자동으로 처리.
- 계층적으로 구조화되어 있기 때문에, 재사용 가능한 서브 뷰를 조합함으로써 복잡한 뷰를 쉽게 만들 수 있음.
- 레이아웃의 모양 변경을 실시간으로 반영하는 미리보기 캔버스를 통해 앱을 빌드해서 실행하지 않고도 완전히 테스트가 가능하다.

### 컴포즈는 데이터 주도적이다
- 컴포즈는 상태(State) 기반 시스템으로 데이터를 상태로 저장해 데이터의 변경을 감지하기 위한 코드를 추가로 작성하지 않아도, 변경사항이 UI에 자동으로 반영된다.
- 상태가 변경되면 해당 데이터를 구독(Subscribe)하는 컴포넌트가 삭제되고 새로운 컴포넌트가 생성되어 상태를 반영, 이 과정을 재구성(Recomposition)이라고 한다.
- 컴포즈는 데이터 변경에 기반해 앱의 동작과 형태를 결정한다는 점에서 데이터 주도적이라 한다. 상태와 재구성을 통해 이를 달성한다.

## 컴포저블 함수 개요(Chapter 19)

### 컴포저블 함수란 무엇인가
- 컴포저블 함수는 컴포즈로 UI를 만들기 위해 이용하는 특수한 코틀린 함수이다.
- @Composable 어노테이션을 이용해 선언하며, 일반 함수와 구별된다.
- 본질적으로 컴포저블 함수는 데이터를 사용자 인터페이스 요소로 변환한다.
- 컴포저블은 컴포즈 런타임으로 사용자 인터페이스 요소를 전달하면 컴포즈 런타임을 통해 렌더링.
- 컴포저블 함수는 다른 컴포저블을 호출함으로써 컴포넌트 계층을 생성할 수 있다.
- 컴포저블 함수에서는 코틀린 표준 함수를 호출하지만, 표준 함수에서는 컴포저블 함수를 호출할 수 없다.
- 전형적인 컴포즈 기반 UI는 내장 컴포저블과 커스텀 컴포저블을 조합하여 구성한다.
- 컴포저블 작성시 재사용성을 최대화하는 것이 중요하다.

### 상태 컴포저블과 비상태 컴포저블
- 컴포저블 함수는 상탯값 저장 여부에 따라 상태 컴포저블과 비상태 컴포저블로 분류된다.
- 상탯값을 저장하기 위해 remember 키워드를 이용하고 mutableStateOf 함수를 호출한다.

### 파운데이션 컴포저블과 머티리얼 컴포저블
- 컴포즈에서 번들르 제공하는 컴포저블은 레이아웃(Layout), 파운데이션(Foundation), 머티리얼 디자인(Material Design) 세 가지로 분류한다.
- 레이아웃 컴포넌트
  - 컴포넌트를 화면에 배치하고, 배치된 컴포넌트들이 상호동작하는 방법을 정의한다.
  - Box, ConstaintLayout, BoxWithConstraints, Row, Column
- 파운데이션 컴포넌트
  - 기본적인 UI 기능을 제공하는 최소한의 컴포넌트 집합
  - 커스텀을 통해 앱의 행태나 행동을 자유롭게 정의할 수 있다.
  - BaseTextField, LazyRow, Canvas, Shape, Text, Image, LazyColumn
- 머티리얼 디자인 컴포넌트
  - 구글이 제공하는 머터리얼 테마 가이드라인을 만족하는 컴포넌트이다.
  - lertDialog, RadioButton, Button, Scaffold, Card, CheckBox, Snackbar, BottomNavigation 등등


## 컴포즈 상태와 재구성(Chapter 20)

### 상태(State)
- 컴포즈에서 상태는 '시간에 따라 변경될 수 있는 값'으로 두가지 면에서 표준변수와 크게 다르다.
- 컴포저블 함수에서 상태 변수에 할당된 값은 기억되어야 한다.
  - 상태를 포함한 컴포저블 함수를 호출할 때마다, 지난 호출때의 상탯값을 기억해야한다.
- 상태 변수의 변경은 UI를 구성하는 컴포저블 함수 계층 트리 전체에 영향을 미친다.
- 상탯값을 선언할 때, 가장 먼저 mutableState 객체로 해당 값을 감싸야한다.
  - mutableState는 옵저버블 타입으로 참조되는 컴포즈 클래스이다.

### 재구성(Recomposition)
재구성은 컴포저블 함수의 계층 안에서 상탯값이 변경될 때 일어난다.
재구성은 해당 상탯값의 변화에 영향을 받는 모든 함수들을 다시 호출하고, 새로운 상탯값을 전달하는 것이다.
전체 컴포저블 트리를 재구성하는 것은 UI 렌더링과 업데이트에 있어 비효율적이다.
상태 변화에 직접 영향을 받는 함수들만 재구성하는 지능적 재구성(intelligent recomposition)을 이용해 오버헤드를 피한다. -> 해당 상탯값을 읽는 함수들만 재구성한다는 뜻이다.


### 단방향 데이터 흐름
- 한 컴포저블에 저장된 상태는 자식 컴포저블 함수들에 의해 직접 변경되어서는 안된다는 개념이다.
- 규칙에 의해 데이터는 컴포저블 계층을 따라 전달되며, 이벤트는 계층의 반대 방향인 조상 컴포넌트의 핸들러로 호출됨.

### 상태 호이스팅(State Hoisting)
- 상태를 자식 컴포저블에서 이를 호출한 부모 컴포저블로 들어 올린다는 개념이다.
- 상태를 부모 함수로 들어 올림으로써 컴포저블의 재사용성과 유연함을 높일 수 있다.
- 함수에 상태를 추가할 때는 호출자에게 상태를 호이스팅 가능한지를 고려해야 한다.

### 환경 설정 변경(Configuration change)을 통한 상태 저장하기
- remember 키워드는 Configuration change에서 상태를 유지하지 않는다.
- remeberSaveable을 키워드를 사용하면 Configuration change 에서도 상태가 유지된다.
