# 1주차 (Chapter 18 ~ 23)

## 컴포즈 개요(Chapter 18)

### 컴포즈 이전의 개발
- 컴포즈 이전에 안드로이드 스튜디오에서는 XML파일을 만들 수 있는 레이아웃 편집기 도구를 제공하였다.
- 씬에서 컴포넌트를 선택하여 다양한 프로퍼티에 접근하여 속성을 변경할 수 있다.
- 사용자 이벤트에 반응하는 모든 컴포넌트는 이벤트를 처리하는 앱의 소스 코드 메서드에 연결된다.
- 시뮬레이터 또는 실제 기기에서 실행하면서 테스트해야 했다.

### 컴포즈의 선언적 구문
- 선언한 레이아웃 배치, 제한, 렌더링 방법에 관한 모든 복잡한 세부 사항은 컴포즈가 자동으로 처리.
- 계층적으로 구조화되어 있기 때문에, 재사용 가능한 서브 뷰를 조합함으로써 복잡한 뷰를 쉽게 만들 수 있음.
- 레이아웃의 모양 변경을 실시간으로 반영하는 미리보기 캔버스를 통해 앱을 빌드해서 실행하지 않고도 완전히 테스트가 가능하다.

### 컴포즈는 데이터 주도적이다
- 컴포즈는 상태(State) 기반 시스템으로 데이터를 상태로 저장해 데이터의 변경을 감지하기 위한 코드를 추가로 작성하지 않아도, 변경사항이 UI에 자동으로 반영된다.
- 상태가 변경되면 해당 데이터를 구독(Subscribe)하는 컴포넌트가 삭제되고 새로운 컴포넌트가 생성되어 상태를 반영, 이 과정을 재구성(Recomposition)이라고 한다.
- 컴포즈는 데이터 변경에 기반해 앱의 동작과 형태를 결정한다는 점에서 데이터 주도적이라 한다. 상태와 재구성을 통해 이를 달성한다.

## 컴포저블 함수 개요(Chapter 19)

### 컴포저블 함수란 무엇인가
- 컴포저블 함수는 컴포즈로 UI를 만들기 위해 이용하는 특수한 코틀린 함수이다.
- @Composable 어노테이션을 이용해 선언하며, 일반 함수와 구별된다.
- 본질적으로 컴포저블 함수는 데이터를 사용자 인터페이스 요소로 변환한다.
- 컴포저블은 컴포즈 런타임으로 사용자 인터페이스 요소를 전달하면 컴포즈 런타임을 통해 렌더링.
- 컴포저블 함수는 다른 컴포저블을 호출함으로써 컴포넌트 계층을 생성할 수 있다.
- 컴포저블 함수에서는 코틀린 표준 함수를 호출하지만, 표준 함수에서는 컴포저블 함수를 호출할 수 없다.
- 전형적인 컴포즈 기반 UI는 내장 컴포저블과 커스텀 컴포저블을 조합하여 구성한다.
- 컴포저블 작성시 재사용성을 최대화하는 것이 중요하다.

### 상태 컴포저블과 비상태 컴포저블
- 컴포저블 함수는 상탯값 저장 여부에 따라 상태 컴포저블과 비상태 컴포저블로 분류된다.
- 상탯값을 저장하기 위해 remember 키워드를 이용하고 mutableStateOf 함수를 호출한다.

### 파운데이션 컴포저블과 머티리얼 컴포저블
- 컴포즈에서 번들르 제공하는 컴포저블은 레이아웃(Layout), 파운데이션(Foundation), 머티리얼 디자인(Material Design) 세 가지로 분류한다.
- 레이아웃 컴포넌트
  - 컴포넌트를 화면에 배치하고, 배치된 컴포넌트들이 상호동작하는 방법을 정의한다.
  - Box, ConstaintLayout, BoxWithConstraints, Row, Column
- 파운데이션 컴포넌트
  - 기본적인 UI 기능을 제공하는 최소한의 컴포넌트 집합
  - 커스텀을 통해 앱의 행태나 행동을 자유롭게 정의할 수 있다.
  - BaseTextField, LazyRow, Canvas, Shape, Text, Image, LazyColumn
- 머티리얼 디자인 컴포넌트
  - 구글이 제공하는 머터리얼 테마 가이드라인을 만족하는 컴포넌트이다.
  - lertDialog, RadioButton, Button, Scaffold, Card, CheckBox, Snackbar, BottomNavigation 등등


## 컴포즈 상태와 재구성(Chapter 20)

### 상태(State)
- 컴포즈에서 상태는 '시간에 따라 변경될 수 있는 값'으로 두가지 면에서 표준변수와 크게 다르다.
- 컴포저블 함수에서 상태 변수에 할당된 값은 기억되어야 한다.
  - 상태를 포함한 컴포저블 함수를 호출할 때마다, 지난 호출때의 상탯값을 기억해야한다.
- 상태 변수의 변경은 UI를 구성하는 컴포저블 함수 계층 트리 전체에 영향을 미친다.
- 상탯값을 선언할 때, 가장 먼저 mutableState 객체로 해당 값을 감싸야한다.
  - mutableState는 옵저버블 타입으로 참조되는 컴포즈 클래스이다.

### 재구성(Recomposition)
- 재구성은 컴포저블 함수의 계층 안에서 상탯값이 변경될 때 일어난다.
- 재구성은 해당 상탯값의 변화에 영향을 받는 모든 함수들을 다시 호출하고, 새로운 상탯값을 전달하는 것이다.
- 전체 컴포저블 트리를 재구성하는 것은 UI 렌더링과 업데이트에 있어 비효율적이다.
- 상태 변화에 직접 영향을 받는 함수들만 재구성하는 지능적 재구성(intelligent recomposition)을 이용해 오버헤드를 피한다. -> 해당 상탯값을 읽는 함수들만 재구성한다는 뜻이다.


### 단방향 데이터 흐름
- 한 컴포저블에 저장된 상태는 자식 컴포저블 함수들에 의해 직접 변경되어서는 안된다는 개념이다.
- 규칙에 의해 데이터는 컴포저블 계층을 따라 전달되며, 이벤트는 계층의 반대 방향인 조상 컴포넌트의 핸들러로 호출됨.

### 상태 호이스팅(State Hoisting)
- 상태를 자식 컴포저블에서 이를 호출한 부모 컴포저블로 들어 올린다는 개념이다.
- 상태를 부모 함수로 들어 올림으로써 컴포저블의 재사용성과 유연함을 높일 수 있다.
- 함수에 상태를 추가할 때는 호출자에게 상태를 호이스팅 가능한지를 고려해야 한다.

### 환경 설정 변경(Configuration change)을 통한 상태 저장하기
- remember 키워드는 Configuration change에서 상태를 유지하지 않는다.
- remeberSaveable을 키워드를 사용하면 Configuration change 에서도 상태가 유지된다.

## CompositionLocal

### CompositionLocal이란?
- 계층의 여러 단계를 통해 상태를 전달해야 할 때 번거로운 문제를 해결해준다.
- 컴포저블 계층 트리 상위에서 선언된 상태를 계층 트리 하위의 함수에서 이용하는 방법 제공한다.
- 해당 상태가 선언된 함수와 상태를 이용하는 함수 사이에 있는 모든 컴포저블에 상태를 전달하지는 않는다.
- 트리의 깊이가 깊을수록 여러 단계의 컴포저블에 상태를 전달해야 하는데, CompositionLocal을 통해 중간 노드에 상태를 전달하지 않고도 하위 노드에서 이용 가능하다.
### CompositionLocal 이용하기
- CompositionLocal을 이용해 상태를 저장하려면 ProvidableCompositionLocal 인스턴스를 생성해야 한다.
- compositionLocalOf() 혹은 staticCompositionLocalOf() 함수를 호출해 얻을 수 있다.
  1. staticCompositionLocalOf() : 상탯값이 변경되면 해당 상태가 할당된 노드의 하위 노드를 모두 재구성해야 하기 때문에 자주 변경되지 않는 상탯값을 저장할 때 이용한다.
  2. compositionLocalOf() : 현재 상태에 접근하는 컴포저블에 대해서만 재구성을 수행하기 때문에 변경이 잦은 상태를 다룰 때 이용한다.
- 이런 방식으로 선언된 상태는 해당 값이 할당된 계층 트리의 브랜치에만 영향을 줌.

## 컴포즈 Slot API
### Slot API 이해하기
- Slot은 개발자가 원하는대로 채울 수 있도록 UI에 빈 공간을 남겨둔다.
- Slot API를 사용하면 컴포저블 함수의 내용을 호출 시점에 동적으로 지정할 수 있다.
- Slot API 패턴을 사용하면 조금 더 재사용성을 높일 수 있다.

### Slot API 선언하기& 컴포저블 호출하기
컴포저블에 슬롯을 추가할 때는 먼저 슬롯을 파라미터로 받을 수 있도록 지정한다.
```kotlin
@Composable
fun SlotDemo(middleContent: @Composable () -> Unit){
	Column{
    	Text("Hello")
      middleContent()
      Text("World")
    }
}
```
위 코드의 SlotDemo에 설정된 Slot API를 사용하기 위해서는 SlotDemo 함수를 호출할 때 컴포저블을 파라미터로 전달하면 된다.
```kotlin
@Composable
fun ButtonDemo() {
	Button(onClick = { }) {
    	Text("Click Me")
    }
}
```
SlotDemo 컴포저블 함수는 아래와 같이 호출할 수 있다.
컴포저블에 2개 이상의 채울 슬롯이 있는 경우에는 복잡해질 수 있기 때문에 2번째처럼 하는 것이 좀 더 명확하다.
```kotlin
// 1)
SlotDemo(Content = { ButtonDemo() })

// 2)
SlotDemo {
  ButtonDemo()
}
```
