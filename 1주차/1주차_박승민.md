# 1 주차 컴포즈 스터디(Ch18 ~ Ch23)

## 1. Compose 특징

### 1.1 컴포즈의 선언적 구문

컴포즈를 이용하면 씬을 구성하는 컴포넌트의 모양과 레이아웃의 복잡한 세부 사항을 직접 디자인하지 않고도, 간단하고 직관적인 구문을 이용해 씬을 기술할 수 있다.

👉 **레이아웃을 빌드하는 접근 방식의 복잡성에 신경쓰지 않고 UI가 표시되는 방식을 선엄함으로써 레이아웃을 만들수 있다!**
👉 **선언만 하면 레이아웃 배치, 제한, 렌더링 방법에 관한 모든 복잡한 세부 사항은 컴포즈가 자동으로 처리한다!**


### 1.2 데이터 주도적

과거에는 변경 가능성이 있는 데이터는 항상 최신 데이터 상태를 반영하도록 코드를 작성해야 했다.

반면 컴포즈는 상태 기반 시스템을 제공해 이런 복잡성을 해결한다.

📌 데이터를 **상태**로서 저장하면 변경사항이 자동으로 UI에 반영된다.
상태에 접근하는 모든 UI 컴포넌트는 기본적으로 그 상태를 구독한다.

앱 코드 안 어디서든 상태가 변경되면, 해당 데이터를 **구독**하는 컴포넌트가 삭제되고 새로운 컴포넌트가 생성되어 상태를 반영한다. 이 과정을 **재구성**이라고 한다.

* * *
## 2. 컴포저블 함수

### 2.1 컴포저블 함수란?
>**``컴포저블 함수(컴포저블, 컴포넌트)``**는 컴포즈로 UI를 만들기 위해 이용하는 특수한 코틀린 함수.

일반적으로 컴포저블이 호출되면 UI의 해당 영역이 렌더링될 때 사용자에게 표시되고 동작되는 방식을 정의하는 데이터와 프로퍼티 집합을 전달한다.


📌 정리하면, 컴포저블 함수는 표준 코틀린 함수와 달리 값을 반환하지 않는다. 대신 컴포즈 런타임에 렌더링되는 UI 유닛을 반환한다.

### 2.2 상태 컴포저블과 비상태 컴포저블

컴포저블 함수는 **``상태 컴포저블``** 과 **``비상태 컴포저블``**로 나뉜다.

상태값을 가지고 있는 컴포저블을 `상태 컴포저블`이라고 하며, 그렇지 않은 컴포저블을 `비상태 컴포저블`이라고 한다.

컴포즈 컨텍스트에서 `상태`는 앱 실행 중 변경될 수 있는 모든 값으로 정의된다.

상태값을 저장하려면 `remember` 키워드와 `mutableStateOf()` 함수를 이용한다.
```kotlin
@Composable
fun Composable1() {
	var state by remember { mutableStateOf(true) }
}
```

* * *

## 3. 컴포즈 상태와 재구성

### 3.1 상태

컴포즈 같은 선언적 언어에서 일반적으로 **상태**는 **시간에 따라 변경될 수 있는 값**이라 불린다.

#### 상태와 표준 변수와의 차이점
**1.** 컴포저블 함수에서 상태 변수에 할당된 값은 기억되어야 한다.
👉 즉 상태 컴포저블을 호출할 때마다, 지난번 호출했을 때의, 상태값을 기억해야 한다.
👉 반면 표준 변수는 선언된 함수를 호출할 때 마다 초기화된다.

**2.** 상태 변수의 변경의 UI를 구성하는 컴포저블 함수 계층 트리 전체에 영향을 미친다.


### 3.2 재구성

컴포저블 함수는 데이터를 받고, 해당 데이터를 이용해 UI 레이아웃 영역을 만든다. 컴포즈 런타임은 이 요소들을 렌더링한다. 

한 컴포저블 함수에서 다른 함수로 전달된 데이터는 대부분 부모 함수에서 상태로서 선언되는데, 이는 부모 컴포저블의 상태값 변화가 모든 자식 컴포저블에 반영되며, 해당 상태가 전달된다는 것을 의미한다.
📌 컴포즈에서 이를 **재구성**이라는 동작으로 실행한다.

재구성은 컴포저블 함수의 계층 안에서 상태값이 변경될 때 일어난다.
커모즈는 상태의 변화를 감지하면, 액티비티의 모든 컴포저블 함수에 대해 해당 상태값의 변화에 영향을 받는 모든 함수를 재구성한다.
이때 오버헤드를 피하기 위해 상태 변화에 직접 영향을 받는 함수들만 재구성을 한다.

**즉, 재구성이란 해당 함수들을 다시 호출하고 새로운 상태값을 전달하는 것.**

### 3.3 단방향 데이터 흐름

>앱 개발에서 **단방향 데이터 흐름**이란, 한 컴포저블에 저장된 상태는 자식 컴포저블 함수들에 의해 직접 변경되어서는 안된다는 개념을 뜻한다.

👉 이를 위해 이벤트 핸들러를 선언하고(_일반적으로 람다 형태_) 자식 컴포저블에게 상태값과 함께 파라미터로 전달한다.

```kotlin
@Composable
fun A() {
	var state by remember { mutableStateOf(true) }
    
    val onClick = { value : Boolean ->
    	state = value
    }
    B(state = state, onClick = onClick)
    
}

@Composable
fun B(state:Boolean, onClick: (Boolean) -> Unit){
	Switch(checked = state, onCheckedChange = onClick)
}
```


위 코드를 보면 부모 컴포저블 A에서 자식 컴포저블 B에게 상태값과 이벤트 핸들러를 파라미터로 전달하여, 자식 컴포저블에서 상태값을 변경하는 것이 아닌, 이벤트 핸들러를 호출하여 현재 상태값을 전달한다. 

- A에 선언된 `onClick` 람다는 `state`에 새로운 값을 할당한다.
- 컴포즈는 상태값이 변경되었음을 감지하고 재구성을 시작한다.
- 이때 컴포즈는 B가 `state`의 값을 읽는 코드를 갖고 있으며 따라서 재구성이되어야 함을 식별한다.
- 컴포즈는 최신 상태값과 이벤트 핸들러에 대한 참조와 함께 B를 호출한다.
- B는 `Switch` 컴포저블을 호출하고 해당 상태와 이벤트 핸들러를 이용해 설정한다.
- 컴포즈는 `Switch`를 화면에 렌더링한다. 

❗ 여기서 중요한 것은 `state`에 할당된 값은 A(_부모 컴포저블_) 안에서만 변경되고 자식 컴포저블인 B에서는 직접 업데이트되지 않는다는 점이다. 대신 A의 이벤트 핸들러를 호출해 상태를 변경하고 그 결과를 재구성함을써 `Switch`를 새로운 위치값으로 만든다.


### 3.4 상태 호이스팅

#### 호이스팅이란?
**`hoist`** : 무언가를 들어 올리는 행동

#### 상태 호이스팅이란?
>상태를 부모 함수로 들어 올림으로써, 자식 컴포저블이 재사용 가능한 `비상태 컴포저블`로 만드는 것.

상태 호이스팅은 컴포저블의 직계 부모로만 제한되지 않는다. 
상태는 컴포저블 계층 안에서 원하는 만큼 들어올릴 수 있으며, 필요한 만큼 자식 레이어를 통해 전달할 수 있다.

종종 여러 자식 컴포저블이 동일한 상태에 접근해야 하는 경우가 있다. 이러한 경우 상태를 해당 자식 컴포저블의 공통 부모에게 들어 올리면 된다.

📌 이때 중요한 것은 **상태를 가장 낮은 공통 상위 요소로 호이스팅하고, 상태를 필요로 하지 않는 컴포저블에 전달하지 않는 것이다.**

![](https://developer.android.com/static/images/jetpack/compose/state-hoisting-animated.gif?hl=ko)

* * *

## 4. CompositionLocal

### 4.1 CompositionLocal 언제 사용할까?

상태는 일반적으로 컴포저블 트리에서 가능한 가장 높은 노드에 선언되어야 하고, 필요한 경우 계층의 하위 컴포저블에 전달해야 한다는 것을 상태 호이스팅에서 배웠다.
다만 계층의 여러 단계를 통해 상태와 이벤트 핸들러를 전달해야 할 경우 다소 번거로울 수 있다.

`CompositionLocal`을 사용하면 중간 자식 노드에 상태를 전달하지 않고도, 트리의 가장 높은 노드에 선언되어 있는 데이터를 하위 노드에서 이용할 수 있다.

※ 단, `CompositionLocal`은 값이 할당된 지점 아래의 트리 분기에서만 데이터를 이용할 수 있다.

### 4.2 CompositionLocal 어떻게 사용할까?

`CompositionLocal`을 이용해 상태를 선언하려면 `ProvidableCompostionalLocal` 인스턴스를 생성해야 한다.
이 인스턴스는 `composionLocalOf()` 와 `staticCompositionLocalOf()` 함수를 호출해서 얻을 수 있다.

```kotlin
val LocalColor = compositionLocalOf { Color.Red }
val LocalColor = staticCompositonLocalOf { Color.Red 
```
- #### compositionLocalOf()
 `compositionLocalOf()` 함수는 현재 상태에 접근하는 컴포저블에 대해서만 재구성을 수행하기 때문에 **변경이 잦은 상태를 다룰 때 이용한다.**


- #### staticCompositionLocalOf()
`staticCompositionLocalOf()` 함수는 상태값이 변경되면 해당 상태가 할당된 노드의 하위 노드를 모두 재구성해야 하기 때문에 **자주 변경되지 않는 상태값을 저장할 때 이용한다.**



#### CompositonLocal에 값 제공

>`CompositionLocalProvider` 컴포저블은 주어진 계층 구조의 `CompositionLocal` 인스턴스에 값을 바인딩합니다. `CompositionLocal`에 새 값을 제공하려면 다음과 같이 `CompositionLocal` 키를 value에 연결하는 `provides` 중위 함수를 사용하세요.

```kotlin
val color = Color.Blue
CompositonLocalProvider(LocalColor provides color){
	// CompostionLocal 제공자의 컨텍스트 안에서 자식 Composable()을 호출해야 한다.
    SubComposable()
}
```


#### CompositonLocal 값 사용

`CompositonLocal.current`는 `CompositonLocal`에 값을 제공하는 가장 가까운 `CompositionLocalProvider`에서 값을 반환한다.

```kotlin
val background = LocalColor.current
```

### 4.3 ComposionLocal 사용시 고려 사항
>`CompositionLocal`에는 적절한 기본값이 있어야 합니다. 기본값이 없으면 개발자가 `CompositionLocal`의 값이 제공되지 않는 매우 곤란한 상황에 처할 수 있다는 것을 확실하게 해야 합니다. 기본값을 제공하지 않으면 테스트를 만들거나 `CompositionLocal`을 사용하는 컴포저블을 미리 볼 때 항상 명시적으로 제공되도록 기본값을 요구해야 하는 문제와 불만이 발생할 수 있습니다.<br>
트리 범위 또는 하위 계층 구조 범위로 간주되지 않는 개념에는 `CompositionLocal`을 사용하지 않습니다. `CompositionLocal`은 잠재적으로 일부 하위 요소가 아닌 모든 하위 요소에서 사용할 수 있을 때 적합합니다.

### 4.4 CompositionLocal 단점

>그러나 `CompositionLocal`이 항상 최선의 솔루션은 아닙니다. `CompositionLocal`을 과도하게 사용하지 않는 것이 좋습니다. 다음과 같은 단점이 있기 때문입니다.<br>
`CompositionLocal`은 컴포저블의 동작을 추론하기 어렵게 합니다. 암시적 종속 항목을 만들 때 이를 사용하는 컴포저블의 호출자는 모든 `CompositionLocal`의 값이 충족되는지 확인해야 합니다.<br>
또한 이 종속 항목은 컴포지션의 모든 부분에서 변경될 수 있으므로 종속 항목에 관한 명확한 정보 소스가 없을 수도 있습니다. 따라서 문제가 발생할 때 앱을 디버깅하는 것이 더 어려울 수 있습니다. 컴포지션을 탐색하여 current 값이 제공된 위치를 확인해야 하기 때문입니다.

### 4.5 Material Theme에서의 CompositonLocal
>`CompositionLocal`은 `Material 테마`에서 내부적으로 사용하는 것입니다. `MaterialTheme`은 나중에 컴포지션의 하위 부분에서 가져올 수 있는 세 개의 `CompositionLocal` 인스턴스(`색상`, `서체`, `도형`)를 제공하는 객체입니다. 이러한 인스턴스는 구체적으로 `LocalColors`, `LocalShapes`, `LocalTypography` 속성으로, `MaterialTheme` `colors`, `shapes`, `typography` 속성을 통해 액세스할 수 있습니다.

* * *

## 5. 컴포즈 Slot API

### 5.1 슬롯이란?

>슬롯은 개발자가 원하는 대로 채울 수 있도록 UI에 빈 공간을 남겨둔다. 예를 들어 다음은 `TopAppBar`에서 맞춤 설정할 수 있는 슬롯이다.
![TopappBar](https://developer.android.com/static/images/jetpack/compose/layout-appbar-slots.png?hl=ko)

- 위와 같이 `Slot API`를 사용하면 컴포저블 함수의 내용을 호출 시점에 동적으로 지정 가능하다.

### 5.2 Slot API 사용법

컴포저블에 슬롯을 추가할 때는 먼저 슬롯을 파라미터로 받을 수 있도록 지정해야 한다.
```kotlin
@Composable
fun SlotDemo(Content: @Composable () -> Unit){
	Column{
    	Text("Hello")
        Content()
        Text("World")
    }
}
```
다음으로 `SlotDemo`에 설정된 `Slot API`를 사용하기 위해서는 `SlotDemo` 함수를 호출할 때 컴포저블을 파라미터로 전달하면 된다.

```kotlin
@Composable
fun ButtonDemo() {
	Button(onClick ={}) {
    	Text("Click")
    }
}

SlotDemo(Content = { ButtonDemo() }) 
```

<br/>
  
  

  
## 출처
  * * *
 

 
- **도서명** 핵심만 골라 배우는 젯팩 컴포즈
**출판사** 제이펍
**저작권사** Payload Media
**원서명** Jetpack Compose Essentials(원서 ISBN 9781951442378)
**부   제** 젯팩 컴포즈, 안드로이드 스튜디오, 코틀린으로 안드로이드 앱 개발하기
**지은이** 닐 스미스
<https://jpub.tistory.com/1357/> 

 - Android 공식문서
 <https://developer.android.com/jetpack/compose/documentation?hl=ko/>

